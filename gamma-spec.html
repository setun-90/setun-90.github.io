<!DOCTYPE html>
<html>
<head>
	<title>SETUN-90 - Gamma Language Specification</title>
	<meta charset="utf-8" />
	<link rel="icon" href="./logo-fill.svg" />
	<link rel="stylesheet" href="./global.css" />
</head>
<body>
	<div id="banner">
		<img id="logo" src="./logo-fill.svg" />
		<h1 id="title">Gamma Language Specification</h1>
	</div>
	<h2>C with fewer bad decisions</h2>
	<h3>Background</h3>
	<p>Even though I came up with the language as described in these documents only in November of 2019, the concepts in this language had been rolling around in my mind for the past year or so.</p>
	<p>The reason why I decided to create a replacement specifically for C, as opposed to some extension or clean-up, is because in my opinion, C occupies a niche that is unavoidable. C combines low-level manipulation of memory with low runtime footprint and yet has features which make it possible and, with discipline, not all too impractical to develop decent applications. The only problem is that it comes with design decisions which do not stem from any requirements of those applications, yet make it more dangerous than is truly necessary. For example, the bitwise operator precedence was chosen for backwards compatibility with B, and the null-terminated byte arrays came from <em>personal</em> experience of Dennis Ritchie and Ken Thompson. Why others accepted adopting this language without insisting on adding some array support escapes me, especially given <a href="https://en.wikipedia.org/wiki/Dope_vector">dope vectors</a> have existed for quite some time. Then again, one would be surprised at the short-sightedness of the IT industry at times. (Or aggravated. Or not surprised at all. I can't tell for you.)</p>
	<p>To put it briefly, the points I took (almost) wholesale from C were:
	<ul>
		<li>Type system: except for a few modifications, arrays, pointers and function pointers have practically exact equivalents in Gamma, and constancy works in the same way;</li>
		<li>Statements: except for minor aesthetic differences, most C statements have direct equivalents;</li>
	</ul>
	while the points that I took the liberty of extending were:
	<ul>
		<li>Type system: function (but not operator) overloading is supported, and a result qualifier was added which makes reading from the datum forbidden. This would have use in, say, routines cooperating in cryptographic applications, where the code must not be able to read confidential output;</li>
		<li>Nested subprograms: a subprogram (function or procedure) can be nested, and obeys the same rules as other local datums (including not returning its address, since it would be tantamount to returning the address of a local - which, newsflash, is undefined behavior in C);</li>
		<li>Array values: array parameters and arguments in subprogram calls now conserve their length (i.e. <code>#arr</code> actually returns the length of the array), obviating the need for things like <code>strlen</code>;</li>
	</ul>
	the points that I took the liberty of modifying were:
	<ul>
		<li>Type system: the basic types were rationalized and made consistent (e.g. <code>n1</code>,<code>n2</code>,<code>n4</code>,<code>n8</code> and so on for unsigned types, and <code>d1</code>,<code>d2</code>,<code>d4</code> and so on for floating-point types, where the number refers to the size of the type - this allows still supporting non-standard arches and byte sizes with considerably less byzantine type names);</li>
		<li>Operator precedence: the bitwise operators are finally put in their proper precedence, ending the <code>(a & b) == c</code> infelicity;</li>
		<li>Syntax: operators are spelt differently, notably casting and pointer dereference, to eliminate the need for the lexer hack, and initializations employ type inference (with casts available in case one needs a short rather than a byte);</li>
		<li>Scoping: datums are defined at subprogram scope by default, like Python, though block scope is still available by labelling statements. This is for initializing locals in conditionals, because datums may not be uninitialized (see below);</li>
		<li>Behavior: some forms of undefined behavior are eliminated, while others are introduced, for reasons which will be explained.</li>
	</ul>
	and the points that I took the liberty of eliminating were:
	<ul>
		<li>File inclusion: this is made redundant with the linkage process described, and is also explained in the implementation notes;</li>
		<li>Uninitialized variables: a variable should be written to before any read, so it makes no sense for the language to allow otherwise;</li>
		<li>Implicit conversions: in fact, some (like pointer conversions) are absolutely forbidden, since differing alignments in the source and target types will often result in undefined behavior. For reinterpreting bytes (e.g. the equivalent of <code>*((float *)&i)</code>), use unions - in fact, pointer conversions like that <em>are</em> undefined behavior in C, but union reinterpretations are not;</li>
		<li>Static locals: if <code>strtok</code> doesn't disturb you, then I guess this won't make much sense :-)</li>
	</ul>
	</p>
	<h3>Documents</h3>
	<p>On this page are links towards PDF documents collectively describing what compiler writers need to know to implement Gamma. Keep in mind that they were written on extremely short notice, and thus gaps, repetitions and even contradictions may be present.<br />
	<table>
		<tr><th>Subject</th><th>Description</th><th>Last change</th></tr>
		<tr>
			<td><a href="./gamma-spec/Language.pdf">Language</a></td><td>Describes the core language.</td><td>Clarified temporary allocations.</td>
		</tr>
		<tr>
			<td><!--<a href="./gamma-spec/Declarations.pdf">-->Declarations<!--</a>--></td><td>Describes the equivalent of the standard library in other languages.</td><td>Alpha release</td>
		</tr>
		<tr>
			<td><!--<a href="./gamma-spec/Implementation.pdf">-->Implementation<!--</a>--></td><td>Explains several design decisions and offers ideas for solving several implementation problems.</td><td>Alpha release</td>
		</tr>
	</table>
	</p>
</body>
</html>
